# 12주차

## **수업에서 나눈 질문들**

**<예제 10-10>**

    A. 10라인과 14라인의 차이점이 무엇일까?  

    B. 10라인의 출력문은 포인터 배열을, 14라인은 2차원 배열을 이용해서 출력한다는 점에서 다른 것 같아. 

    A. 결과 값이 같으니 값에 접근하는 방식도 같다고 생각하면 될까?  
    
    B. 둘의 접근 방식에도 다른 점이 있어.

    A. 포인터의 특성과 연관이 있나? 

    B. 그렇지. %s 서식 지정자를 통해 포인트 배열은 해당 포인터가 가리키는 문자열을 출력하고, 2차원 배열에서는 해당 행의 시작 주소에 위치한 문자열을 출력하는 거야.

    A. 그러면 포인터 배열의 경우는 각 요소가 문자열을 직접 가리키는 포인터이고, 2차원 배열은 각 행이 문자열을 나타내 배열의 이름 자체가 해당 행의 시작 주소를 나타내는 거네? 

    B. 맞아.

**<예제 10-11>**

    A. 소문자를 대문자로 만들려면 아스키코드를 사용해야겠지?

    B. 맞아. 'a'가 97이고 'A'가 65이니까, 32를 빼주면 되겠다.

    A. 우선 문자열을 가리키는 포인터를 선언하고 초기화해 줬어. 

    B. 포인터가 가리키는 값이 NUILL이 아니라면 계속 반복해야 하니까 while문을 써서 pC값을 1씩 증가시켜 다음 문자로 이동하게 하자.

    A. 증가시키기 전에는 포인터가 가리키는 문자를 대문자로 바꿔주는 출력문을 작성해야 해. printf("%c", *pC - 32); 포인터가 가리키고 있는 문자에서 32를 빼면 대문자로 바뀌어 출력될 거야.

    B. 포인터를 이용한 소문자->대문자 변환이 잘 작동하네. 반대로 대문자->소문자로 만들려면 32를 더해주면 되겠지?

    A. 그러면 될 것 같아.

**<예제 11-7>**

    A. 구조체를 인자로 받는 것과 구조체 포인터를 인자로 받는 것의 정확한 차이를 모르겠어. 

    B. 구조체 포인터를 인자로 받는 것은 함수에 구조체의 주소가 전달되는 거라고 생각하면 돼. 
    B. 복사가 아니라 원본 데이터를 가리키는 포인터가 전달되는 반면에 구조체를 인자로 받는 경우에는 구조체의 복사본이 함수에 저장되는 거지. 

    A. 그러면 구조체 포인터를 인자로 받게 되면 원본 데이터에도 접근이 가능하겠네?

    B. 맞아. 포인터를 통해 직접 데이터를 조작하기 때문에 함수 내에서 구조체를 변경하면 원본 구조체도 영향을 받아.
    B. 또한 구조체를 인자로 받게 되면 함수에 복사된 구조체에만 영향을 미치고 원본 구조체에는 영향을 주지 않지.
 
    A. 찾아보니깐 두 방법 중 어떤 것을 선택할지는 사용자의 요구사항과 코드의 목적에 따라 다르다고 하네.

    B. 원본 구조체를 변경할 필요가 있는지, 메모리 사용을 최소화해야 하는지, 효율적으로 데이터를 조작할 필요가 있는지 등을 고려하여 선택하면 될 거야.
    
---

## **수업 내용 정리**
### <10장>

### 포인터와 문자열

1. 포인터를 이용한 문자열 선언 방법
    - `char*포인터명 = “문자열”;`
2. 배열 포인터
    - 문자열을 동시에 여러 개 만들어야 하는 경우 유용
    - `char*pStr[3] = {”English”, “math”, “Korean”};`
    - pStr[0]은 e, pStr[1]은 m
    - 불필요한 메모리 낭비를 막을 수 있기 때문에 배열의 크기를 초기에 지정하지 않아도 됨
    - 2차원 배열 이용 시 문자가 가장 많은 문자열이 기준이 되어 메모리 낭비 발생
3. 문자 처리 함수
    - 시스템에서 문자를 처리하는 함수들을 헤더파일인 ctype.h 파일에 만들어 놓음
4. 문자열 처리 함수
    - 시스템에서 문자를 처리하는 함수들을 헤더파일인 string.h 파일에 만들어 놓음
5. size_t strlen(const char*)
    - `strlen()`함수는 문자열을 입력받아 \0을 제외한 문자열의 크기를 반환
6. int strcmp(const char* s1, const char s2)
    - `strcmp( )` 함수는 문자열 2개를 입력받아 두 문자열을 비교
    - 두 문자열이 같으면 0을 반환, (s1<s2)이면 -1, 반대이면 1 반환
7. char* strcpy(char* s1, const char* s2)
    - `strcpy( )` 함수는 문자열 2개를 입력받아 첫 번째 문자열에 두 번째 문자열 복사
    - 첫 번째 문자열 ≥ 두 번째 문자열보다 크기(길이)
8. char* strcat(char* s1, const char* s2)
    - `strcat( )` 함수는 문자열 2개를 입력받아 첫 번째 문자열에 두 번째 문자열 연결
    - 첫 번째 문자열의 크기 ≥ 두 문자열을 합한 크기

### <11장>

### 구조체의 정의와 변수 선언

1. 구조체
    - 서로 다른 자료형을 하나의 자료로 구조화한 자료형
    - `키워드 (struct) + 구조체명`으로 정의
    - struct 안의 각 구성 요소인 멤버는 `{}` 안에 정의
    - 마지막 `{}` 다음에 반드시 세미콜론 포함
2. 구조체 변수 선언
    - 구조체의 정의는 `struct + 구조체명 {};` 안에서
    - 구조체의 선언은 `int main() {};` 안에서
3. 구조체를 정의하면서 변수 선언
    - `struct + 구조체명 {} 변수1, 변수2;`
    - 구조체명을 기록하지 않으면 변수를 선언할 때마다 구조체의 정의 부분을 다시 작성해야 함

### 구조체의 접근과 사용

1. 구조체의 선언과 초기화

- struct + 구조체명 {}; 뒤에 `struct + 구조체명 + 변수명 = {”Moon”, “Seoul”, 28};` or `변수명 = {”Moon”, “Seoul”, 28};`
1. 구조체 멤버 연산자
    - 구조체 멤버 변수에 접근 시 도트(.) 연산자 사용
2. 구조체 멤버 변수의 형식과 사용 예
    - 구조체 변수명.멤버명 → `st1.age`
3. 할당 연산자를 이용한 값의 저장
    - `st2 = st1;`는 st2의 멤버가 st1의 멤버로 초기화
    - `st2.name = st1.name;` 는 해당하는 멤버만 초기화

### 구조체의 재정의

1. typedef
    - 자료형을 재정의하는 키워드
2. typedef를 이용한 자료형 재정의
    - `typedef + struct + students + student;` 는 구조체명 struct students를 student로 간단하게 재정의
3. typedef를 이용한 구조체 자료형 재정의
    - 자료형 재정의를 `typedef struct {} student;` 하면 구조체 객체의 선언은 `student st1 = {};`로 가능
4. 구조체를 이용한 3차원 좌표 표시
    - `struct ThreeDime{double x; double y; double z;};`
5. 3차원상에서 두 점 간의 거리 구하기
    - 원점-점 A1(x1, y1, z1)의 거리 `D = ROOT(x12+y12+z12)`
    - 점 A1과 점 A2의 거리 `D = ROOT((x1-x2)2 + (y1-y2)2 + (z1-z2)2)`

### 구조체의 사용

1. 포인터를 이용한 구조체 사용
    - 도트(.) 연산자: 일반 변수 형태로 정의한 구조체의 멤버 변수에 접근
    - 화살표(→) 연산자: 포인터 변수 형태로 정의한 구조체의 멤버 변수에 접근
2. 구조체 포인터의 사용 방법
    - 구조체 포인터의 선언과 초기화는 `typedef struct ThreeDime ThreeDime;`로 재정의
    - `ThreeDime A1 = {3, 1, 8};`로 구조체 객체 선언
    - `ThreeDime*pA1 = &A1;`포인터 선언과 초기화
    - `구조체 포인터 → 멤버명`, `pA1 → x` 구조체 포인터를 이용해 구조체 멤버 접근
3. 구조체를 인자로 받는 함수
    - 3차원상의 한 점과 원점의 거리를 구하는 함수
    - 3차원상의 두 점 간의 거리를 구하는 함수
    - 3차원상의 한 점을 원점에 대칭시킨 점을 구하는 함수
    
4. 구조체 포인터를 인자로 받는 함수
    - 3차원상의 한 점과 원점의 거리를 구하는 함수
    - 3차원상의 두 점 간 거리를 구하는 함수
    - 3차원상의 한 점을 원점에 대칭시킨 점을 구하는 함수

### 열거형

1. 열거형
    - 순서가 있고 새로운 값(상수)을 가질 수 있는 사용자 정의 자료형
2. 열거형의 정의와 사용 
    - enum 열거형 태그 {열거형 상수 리스트};
    - enum color {yellow, red, blue, green, magenta};
3. 열거형의 선언
    - 초기화와 선언을 따로 `enum color col = red;`
    - 초기화와 선언을 같이 `enum color {yellow, red, blue, green, magenta} col;`
4. 정수형 변수인 color 값에 따라서 색을 표시하도록 프로그래밍
    - int color;로 정의 후 if(color==0){} 로 색을 표시하도록 한다. 0은 첫 번째 상수 yellow를 의미
5. color를 열거형으로 선언한 프로그래밍
    - enum {yellow, red, blue, green, magenta} color; 으로 선언 후 if(color == yellow){}
