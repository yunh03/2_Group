# 14주차
## **수업에서 나눈 질문들**
**예제 13-1**

    A:  선택 정렬 함수를 어떻게 구현할 수 있을까?

    B: 우선 함수를 먼저 정의해 보자. void Select_Sort(int* a, int count); 이렇게 정수형 포인터와 변수를 매개변수로 받는 함수를 선언했어.
    
    A: main 함수 부분은 복사하고 정렬 부분만 구현하라고 하셨으니까 Select_Sort 문만 완성시키면 돼.
    
    B: 배열에서 요소가 10개니까 범위는 0부터 count-1로 잡고 요소를 하나씩 돌면 비교에서 필요한 게 최소값과 최소값의 인덱스이니까 각각을 int로 선언하고 초기화해 주자.
    
    A: 이제 다시 for문으로 비교문을 구현해야 해. 현재 위치의 다음 인덱스부터 시작해서 배열의 끝까지 비교를 해야 하니 j의 범위는  i+1부터 count까지가 되겠다.
    
    B: 그리고 우리가 선언한 최소값을 배열의 각 요소와 비교해서 최소값보다 더 작은 값을 다시 최소값으로 지정해 주면 될까?

    A: 최소값의 인덱스도 함께 업데이트해줘야 해. 그리고나서  a[min_index] = a[i]; 그 값을 최소값이 있던 자리로 보내주고, 
       a[i] = min_value; 이전의 최소값은 현재의 인덱스로 이동시켜 주는 거지.

  **예제 13-2**
  
    A: 선택 정렬과 버블 정렬의 차이는 무엇일까?

    B: 선택 정렬은 위에서 구현했던 것처럼 최소값을 찾아 위치를 이동시키는 방식인데 버블 정렬은 인접한 두 원소를 비교하여 자리를 교환하는 식으로 정렬돼. 
    
    A: 그러면 선택 정렬은 비교하는 횟수가 일정한 반면 버블 정렬은 교환 횟수가 많아질 수도 있는 거네.
    
    B: 맞아. 버블 정렬은 구현 방법에 따라 안정적이지 않을 수 있다고 해. 선택 정렬과 다른 점은 if문부터인 것 같아
    
    A: 인접한 두 값을 비교하고 만약 오른쪽 값이 더 작을 경우에는 위치를 교환해야 하니까, 임시로 변수를 저장할 곳이 필요하겠다.
    
    B: 그걸 int temp;으로 정의해 주고, temp에는 j-1값을, j-1는 오른쪽 값인 j를 저장했다가 다시 temp에 있는 값을 j로 돌려주면 될 거야. 

**예제 13-4**

    A: 왜 삽입 정렬을 보완한 것이 셸 정렬이지?

    B: 먼 거리에 있는 요소들 간의 교환 횟수가 적다는 삽입 정렬의 단점을 보완하기 위해 간격을 도입한 게 셸 정렬 알고리즘이야.  
    
    A: 구현에서는 어떤 부분이 다른 거야?
    
    B: 셸 정렬에서는 간격을 조정하며 부분 리스트에 대해 삽입 정렬을 수행하도록 코드를 짜야 해.
    
    A: 그러면 간격을 조정하는 반복문과 각 부분의 리스트에 삽입 정렬을 수행하는 반복문이 필요하겠네.
    
    B: 맞아. 간격 h의 범위는 count/2로 시작해서 0보다 큰 수까지로 정의해 주고 점점 반으로 줄여가며 반복시키면 돼.
    
## **내용 정리**
**데이터 정렬 프로그램**

1. 선택 정렬 과정
    - 리스트에서 가장 작은 원소를 찾음
    - 찾은 원소를 리스트의 첫 번째 원소와 교환
    - 리스트에서 가장 작은 값을 벽 앞의 정렬된 리스트로 넘김
    - 가상의 벽을 현재 위치에서 한 칸 뒤로 옮겨 검색 범위를 좁힘
2. 버블 정렬 과정
    - 뒤에서부터 앞으로 값을 하나하나 비교하면서 현재 값보다 작은 값이 나타나면 자리를 바꿈. 현재 값이 더 크거나 같으면 앞의 값이 현재 값이 됨.
    - 위의 과정 반복 시 가장 작은 값이 리스트의 맨 앞에 옴
    - 가상의 벽을 한 칸씩 뒤로 옮겨 리스트의 범위를 좁힘
3. 삽입 정렬 과정
    - 가상의 벽 앞과 뒤 값 비교
    - 뒤에 있는 값이 크면 벽을 한 칸 뒤로 옮김
    - 뒤에 있는 값이 작으면 그 값을 정렬된 리스트 뒤에서부터 비교
    - 이동하는 값보다 작은 값이 있을 경우 앞으로 이동
    - 가상의 벽을 한 칸씩 뒤로 옮겨 리스트의 범위를 좁힘
4. 셸 정렬
   
   : 삽입 정렬을 개선한 방법
    
    - h의 간격을 설정
    - h 간격만큼 떨어진 원소를 모은 부분 집합에서 삽입 정렬을 각각 수행
    - h 간격을 재설정하고 위의 과정 반복
6. 퀵 정렬
   
   : 빠른 속도와 간단한 구현으로 여러 분야에서 많이 사용하는 정렬 알고리즘
    
    - 기준 원소 피벗을 고름
    - 피벗을 기준으로 피벗보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동
    - 피벗은 가만히 두고 왼쪽과 오른쪽 원소 집합을 독립적으로 다시 퀵 정렬
